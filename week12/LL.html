<script>
var regexp = /([0-9\.]+)|( +)|([\r\n]+)|(\+)|(\-)|(\*)|(\/)/g;
var dictionary = ["Number", "WhiteSpace", "LineTerminator", "+", "-", "*", "/"];

function* tokenize(source){ // Generator
    let result = null;
    let lastIndex = 0;
    while((result = regexp.exec(source)) !== null){
        let token = {
            type: null,
            value: null
        }

        if(regexp.lastIndex - lastIndex > result[0].length)
            throw new Error(`Unexpected token "${source.slice(lastIndex, regexp.lastIndex - result[0].length)}"!`);

        for(let i = 0; i < dictionary.length; i++){
            if(result[i + 1])
                token.type = dictionary[i];
        }
        token.value = result[0];

        lastIndex = regexp.lastIndex;
        yield token;
    }
    yield {type: "EOF"};
}

// TODO: 实现括号运算

/*
四则运算产生式

<Expression> ::=
    <AdditiveExpression> <EOF>
*/
function Expression(source){
    if(source[0].type === "AdditiveExpression" && source[1].type === "EOF"){
        let node = {
            type: "Expression",
            children: [source.shift(), source.shift()]
        }
        source.unshift(node);
        return node;
    }
    AdditiveExpression(source);
    return Expression(source);
}

/*
加法运算产生式

<AdditiveExpression> ::=
    <MultiplicativeExpression>
    | <AdditiveExpression> <+> <MultiplicativeExpression>
    | <AdditiveExpression> <-> <MultiplicativeExpression>

把<MultiplicativeExpression>展开后：

<AdditiveExpression> ::=
    <Number>
    | <MultiplicativeExpression> <*> <Number>
    | <MultiplicativeExpression> </> <Number>
    | <AdditiveExpression> <+> <MultiplicativeExpression>
    | <AdditiveExpression> <-> <MultiplicativeExpression>
*/
function AdditiveExpression(source){
    // <MultiplicativeExpression>
    if(source[0].type === "Number"){
        MultiplicativeExpression(source);
    }

    // <AdditiveExpression>
    if(source[0].type === "MultiplicativeExpression"){
        let node = {
            type: "AdditiveExpression",
            children: [source.shift()]
        }
        source.unshift(node);
        return AdditiveExpression(source);
    }

    // <AdditiveExpression> <+> <MultiplicativeExpression>
    if(source[0].type === "AdditiveExpression" &&
        source.length > 1 && source[1].type === "+"){
        let node = {
            type: "AdditiveExpression",
            children: [source.shift(), source.shift()]
        }
        MultiplicativeExpression(source);
        node.children.push(source.shift());
        source.unshift(node);
        return AdditiveExpression(source);
    }

    // <AdditiveExpression> <-> <MultiplicativeExpression>
    if(source[0].type === "AdditiveExpression" &&
        source.length > 1 && source[1].type === "-"){
        let node = {
            type: "AdditiveExpression",
            children: [source.shift(), source.shift()]
        }
        MultiplicativeExpression(source);
        node.children.push(source.shift());
        source.unshift(node);
        return AdditiveExpression(source);
    }

    if(source[0].type === "AdditiveExpression")
        return source[0];

    throw new Error();
}

/*
乘法产生式

<MultiplicativeExpression> ::=
    <Number>
    | <MultiplicativeExpression> <*> <Number>
    | <MultiplicativeExpression> </> <Number>
*/
function MultiplicativeExpression(source){
    // <Number>
    if(source[0].type === "Number"){
        let node = {
            type: "MultiplicativeExpression",
            children: source.shift()
        }
        source.unshift(node);
        return MultiplicativeExpression(source);
    }
    // <MultiplicativeExpression> <*> <Number>
    if(source[0].type === "MultiplicativeExpression" && 
        source.length > 1 && source[1].type === "*"){
        let node = {
            type: "MultiplicativeExpression",
            children: [source.shift(), source.shift(), source.shift()]
        }
        source.unshift(node);
        return MultiplicativeExpression(source);
    }
    // <MultiplicativeExpression> </> <Number>
    if(source[0].type === "MultiplicativeExpression" && 
        source.length > 1 && source[1].type === "/"){
        let node = {
            type: "MultiplicativeExpression",
            children: [source.shift(), source.shift(), source.shift()]
        }
        source.unshift(node);
        return MultiplicativeExpression(source);
    }
    if(source[0].type === "MultiplicativeExpression")
        return source[0];

    throw new Error(); 
}

let  source = [];
for(let token of tokenize("5 + 1024 * 2")){
    if(token.type !== "WhiteSpace" && token.type !== "LineTerminator")
        source.push(token);
}

console.log(Expression(source));
</script>