# 编程训练
## 四则运算

LL算法：从左到右移入，从左到右合并。  
LR算法：从左到右移入，从右到左合并。

#### 模块化前端组件化的意义：  
* 控制复杂性，一个系统复杂性一般很高，但当把系统合理地拆成模块后，复杂性就变成了单个模块的复杂性，模块拆得粒度越细，单个模块的复杂性就越好控制。  
* 其次还有复用性的意义。
* AMD/CMD是提供模块化的一种实现方式，并非是必要的，其他方式也可实现模块化。
* 设计模块的方法论之一：高内聚低耦合

#### 为什么要高内聚低耦合：  
* 高内聚低耦合是讲模块的，如果没有模块，就不存在这个概念。
* 高内聚：如果模块里明显不高内聚，一部分代码与另一部分代码没多大联系，那为何不拆成两个模块？
* 低耦合：如果做不到低耦合，A模块与B模块频繁互相调用，那为何A和B不合成一个模块？
* 高内聚低耦合并非目的，而是衡量模块合理性的标示。

#### 字符串分析算法
* 字典树 O(n)
    * 大量字符串的完整模式匹配  
    * 求前50多、前50大都可以用trie，普通排序复杂度是nlogn，用trie树接近o(n)，空间换时间。
    * trie性能经常超乎想象的好，可以排序超过nlogn，因为trie是把数字当做可哈希的，而经典排序之所以卡在nlogn是因为认为只能比较不能哈希，是否哈希算法不一样，但现实中其实几乎见不到不可哈希的（GUID不可哈希不可比较，可比较不可哈希的东西非常少，比如存的文件）
    * 如果一种数据类型互相间可以比较，这个特性在离散数学里叫偏序性；可哈希是偏序性升级版本，不但能比，还能比出来差多少，如1比10小，5比10小，1比10就小的更多。
    * 四种经典排序：快排、归并、堆、希尔，建立的假设是偏序性。可哈希的就可以用字典树。
    * md5、SHA1都是文件摘要的哈希算法，特点是变一个字符哈希出的值变很大。
    * 首字母哈希算法，子段哈希，字符串越相似，哈希出的结果越接近。
    * Optional：寻路sorted可以换成Trie树，可以更快，take算法复杂度可以是O(1)
* KMP O(n)
    * 长字符串中找子串 O(m+n)
* WildCard 通配符算法 O(n)
    * 长字符串中找子串升级版
    * optional：实现?
* 正则
    * 字符串通用模式匹配
* 状态机
    * 通用的字符串分析
* LL LR
    * 字符串多层级结构分析

用栈来处理括号匹配的算法，其实是LR(0)算法
